<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T80 Music</title>
    <style>
        /* --- Base Styles --- */
        :root {
            --bg-color: #191919; /* Slightly lighter dark */
            --primary-color: #252525; /* Card background */
            --secondary-color: #333333; /* Playlist background */
            --text-color: #e0e0e0;
            --text-secondary-color: #a0a0a0; /* For time, less prominent text */
            --accent-color: #007bff; /* One UI Blue */
            --accent-color-alt: #007bff; /* Darker blue for variety */
            --highlight-color: #404040; /* Hover background */
            --slider-thumb-color: #b0b0b0;
            --slider-track-color: #454545;
            --disabled-color: #5a5a5a;
            --icon-color: #b0b0b0; /* Default icon color */
            --icon-color-active: var(--accent-color); /* Active icon color (Blue) */
            --danger-color: #f44336;
            --border-radius-main: 30px; /* Consistent rounding */
            --border-radius-small: 20px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif; /* System fonts */
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            -webkit-font-smoothing: antialiased; /* Smoother fonts */
            -moz-osx-font-smoothing: grayscale;
        }
        .music-player {
            background-color: var(--primary-color);
            border-radius: var(--border-radius-main);
            padding: 20px 25px 25px 25px; /* Slightly adjusted padding */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 480px; /* Slightly adjusted max-width */
            display: flex;
            flex-direction: column;
            gap: 18px; /* Increased gap slightly */
        }

        /* --- File Buttons --- */
        .file-buttons { display: flex; gap: 12px; flex-wrap: wrap; }
        .file-btn {
            background-color: var(--accent-color);
            color: white;
            border: none;
            padding: 10px 18px; /* Adjusted padding */
            border-radius: var(--border-radius-small); /* Less rounded */
            font-size: 0.9rem;
            font-weight: 500; /* Medium weight */
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-grow: 1;
        }
        .file-btn:hover { background-color: #0069d9; } /* Slightly darker blue on hover */
        .file-btn:active { transform: scale(0.97); }
        .file-btn svg { width: 16px; height: 16px; fill: white; }
        #add-files-btn { background-color: var(--accent-color-alt); }
        #add-files-btn:hover { background-color: var(--accent-color); }

        /* --- Playlist --- */
        #playlist-container {
            background-color: var(--secondary-color);
            border-radius: var(--border-radius-small);
            max-height: 240px; /* Adjusted height */
            overflow-y: auto;
            padding: 8px; /* Reduced padding inside container */
            margin-top: 5px;
        }
        #playlist-container h3 {
             margin: 5px 5px 10px 5px; /* Added horizontal margin */
             padding-bottom: 6px;
             border-bottom: 1px solid var(--highlight-color);
             font-size: 0.85rem; /* Smaller heading */
             font-weight: 600; /* Bolder heading */
             color: var(--text-secondary-color);
             text-transform: uppercase; /* Uppercase heading */
             letter-spacing: 0.5px;
        }
        #playlist { list-style: none; }
        #playlist li {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 10px; /* Increased vertical padding */
            cursor: pointer;
            border-radius: 20px; /* Slightly less rounded items */
            transition: background-color 0.15s ease;
            font-size: 0.9rem;
            overflow: hidden;
            margin-bottom: 2px; /* Small gap between items */
        }
        #playlist li .track-name {
             white-space: nowrap;
             overflow: hidden;
             text-overflow: ellipsis;
             flex-grow: 1;
             margin-right: 10px;
             color: var(--text-color); /* Ensure name uses main text color */
        }
        #playlist li:hover { background-color: var(--highlight-color); }
        #playlist li.active { background-color: var(--accent-color); color: white; font-weight: 500; }
        #playlist li.active .track-name { color: white; }
        #playlist li.active .remove-btn { color: rgba(255, 255, 255, 0.8); }
        #playlist li.active .remove-btn:hover { color: white; }

        .remove-btn {
            background: none; border: none; color: var(--icon-color);
            cursor: pointer; font-size: 1.3rem; /* Slightly larger 'x' */
            padding: 0 5px; margin-left: 5px; line-height: 1;
            transition: color 0.2s ease, transform 0.1s ease;
            flex-shrink: 0;
        }
        .remove-btn:hover { color: var(--danger-color); transform: scale(1.1); }
        .remove-btn:active { transform: scale(1); }

        /* --- Track Info & Progress --- */
        .track-info { text-align: center; margin-top: 15px; } /* Increased margin */
        #current-track-name {
             font-size: 1.05rem; /* Slightly smaller */
             font-weight: 500;
             display: block;
             margin-bottom: 10px; /* Increased space */
             min-height: 1.4em; /* Adjust min-height */
             color: var(--text-color);
        }
        .time-display {
            font-size: 0.8rem; /* Slightly smaller time */
            color: var(--text-secondary-color);
            display: flex;
            justify-content: space-between;
            padding: 0 5px;
            margin-top: 8px; /* More space */
        }
        #progress-bar {
             width: 100%;
             margin-top: 8px;
             cursor: pointer;
             height: 8px; /* Make slider track slightly thicker */
        }
        #progress-bar::-webkit-slider-runnable-track { height: 8px; }
        #progress-bar::-moz-range-track { height: 8px; }
        #progress-bar::-webkit-slider-thumb {
             width: 18px; /* Slightly larger thumb */
             height: 18px;
             margin-top: -5px; /* Re-center thumb */
        }
        #progress-bar::-moz-range-thumb { width: 18px; height: 18px; }

        /* --- Controls --- */
        .controls {
             display: flex;
             justify-content: space-evenly;
             align-items: center;
             margin-top: 20px; /* More margin */
             padding: 0 10px;
         }
        .control-btn {
            background: none; border: none; color: var(--icon-color);
            cursor: pointer; padding: 12px; /* Slightly more padding */
            transition: color 0.2s ease, transform 0.1s ease;
        }
        .control-btn svg { width: 24px; height: 24px; fill: currentColor; } /* Slightly larger side icons */
        .control-btn:hover { color: var(--text-color); } /* Change icon color on hover */
        .control-btn:active { transform: scale(0.94); } /* Slightly stronger active effect */
        .control-btn:disabled { color: var(--disabled-color); cursor: not-allowed; transform: none; opacity: 0.4; }
        .control-btn.active { color: var(--icon-color-active); } /* Use Accent blue for active */

        #play-pause-btn svg { width: 40px; height: 40px; } /* Larger play/pause */
        #play-pause-btn:hover { color: var(--accent-color); } /* Accent color only for play/pause hover */
        #repeat-btn { position: relative; }
        #repeat-btn-state {
             position: absolute; bottom: 2px; right: 2px; font-size: 9px; /* Smaller indicator */
             font-weight: 600; color: var(--icon-color-active); background-color: var(--primary-color);
             border-radius: 50%; width: 11px; height: 11px; line-height: 11px;
             text-align: center; display: none;
         }

        /* --- Extra Controls (Volume/Speed) --- */
        .extra-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px; /* Increased gap */
            margin-top: 20px;
            background-color: transparent; /* Remove separate background */
            padding: 0 5px; /* Minimal padding */
        }
        .volume-control, .speed-control { display: flex; align-items: center; gap: 10px; flex-grow: 1; }
        /* Removed text labels - relying on icons and values */
        .volume-control span:first-child, .speed-control span:first-child { /* Target only the icon span */
             font-size: 1.1rem; /* Slightly larger icon */
             color: var(--icon-color);
             min-width: auto; /* Remove min-width */
        }
         .speed-control span:first-child { /* Target only the 'Speed' icon span if you add one */
              /* Add styles if you replace "Speed:" with an icon */
         }
         .speed-control #speed-display { /* Target the value display */
              font-size: 0.8rem;
              color: var(--text-secondary-color);
              min-width: 35px; /* Keep min-width for value */
              text-align: center;
         }

        .volume-control input[type="range"], .speed-control input[type="range"] {
            flex-grow: 1; cursor: pointer; width: auto;
            height: 6px; /* Slimmer extra sliders */
        }
        .volume-control input[type="range"]::-webkit-slider-runnable-track,
        .speed-control input[type="range"]::-webkit-slider-runnable-track { height: 6px; }
        .volume-control input[type="range"]::-moz-range-track,
        .speed-control input[type="range"]::-moz-range-track { height: 6px; }
        .volume-control input[type="range"]::-webkit-slider-thumb,
        .speed-control input[type="range"]::-webkit-slider-thumb {
             width: 15px; height: 15px; margin-top: -4.5px; /* Adjust thumb centering */
        }
        .volume-control input[type="range"]::-moz-range-thumb,
        .speed-control input[type="range"]::-moz-range-thumb { width: 15px; height: 15px; }


        /* Sliders */
        input[type="range"] { -webkit-appearance: none; appearance: none; width: 100%; background: var(--slider-track-color); border-radius: 3px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; background: var(--slider-thumb-color); border-radius: 50%; cursor: pointer; transition: background-color 0.2s ease; }
        input[type="range"]::-moz-range-thumb { background: var(--slider-thumb-color); border-radius: 50%; cursor: pointer; border: none; transition: background-color 0.2s ease; }
        input[type="range"]:hover::-webkit-slider-thumb { background: var(--accent-color); }
        input[type="range"]:hover::-moz-range-thumb { background: var(--accent-color); }

        /* Scrollbar */
        #playlist-container::-webkit-scrollbar { width: 6px; } /* Slimmer scrollbar */
        #playlist-container::-webkit-scrollbar-track { background: var(--secondary-color); border-radius: 3px; }
        #playlist-container::-webkit-scrollbar-thumb { background-color: var(--highlight-color); border-radius: 3px; border: 1px solid var(--secondary-color); }
        #playlist-container::-webkit-scrollbar-thumb:hover { background-color: var(--slider-thumb-color); }

        /* Hidden Inputs */
        #folder-input, #add-files-input { display: none; }

    </style>
</head>
<body>

    <div class="music-player">
        <!-- Hidden Inputs -->
        <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;" accept=".mp3,.wav,.ogg,.m4a,.flac">
        <input type="file" id="add-files-input" multiple style="display: none;" accept=".mp3,.wav,.ogg,.m4a,.flac">

        <!-- Action Buttons -->
        <div class="file-buttons">
             <button id="select-folder-btn" class="file-btn">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"/></svg>
                 Load Folder (Replace)
             </button>
             <button id="add-files-btn" class="file-btn">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm4 18H6V4h7v5h5v11zM8 15.01l1.41 1.41L11 14.84V19h2v-4.16l1.59 1.59L16 15.01 12.01 11z"/></svg>
                 Add Files
             </button>
        </div>

        <div id="playlist-container">
            <h3>Playlist</h3>
            <ul id="playlist"></ul>
        </div>

        <div class="track-info">
            <span id="current-track-name">No track loaded</span>
            <input type="range" id="progress-bar" value="0" step="0.1" disabled>
            <div class="time-display">
                <span id="current-time">0:00</span>
                <span id="total-time">--:--</span>
            </div>
        </div>

        <audio id="audio-player"></audio>

        <div class="controls">
            <button id="shuffle-btn" class="control-btn" title="Shuffle Off">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/></svg>
            </button>
            <button id="prev-btn" class="control-btn" title="Previous" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6 6h2v12H6zm3.5 6 8.5 6V6z"/></svg>
            </button>
            <button id="play-pause-btn" class="control-btn" title="Play" disabled> <!-- Simplified title -->
                <svg id="play-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                <svg id="pause-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" style="display: none;"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
            </button>
            <button id="next-btn" class="control-btn" title="Next" disabled>
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M16 6h2v12h-2zm-4.5 6L6 18V6z"/></svg>
            </button>
            <button id="repeat-btn" class="control-btn" title="Repeat Off">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/></svg>
                 <span id="repeat-btn-state">1</span>
            </button>
        </div>

         <div class="extra-controls">
             <div class="volume-control">
                 <span><!-- Volume icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                 </span>
                 <input type="range" id="volume-slider" min="0" max="1" step="0.01" value="1" title="Volume Control">
             </div>
             <div class="speed-control">
                 <span><!-- Speed icon (using text as placeholder) -->
                    <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px" fill="currentColor"><path d="M10.41 12L13 9.41 11.59 8 8 11.59 11.59 15.17 13 13.76 10.41 11.18zm0 0h13v-2h-13z" opacity=".87"/><path fill="none" d="M0 0h24v24H0z"/></svg> <!-- Simple speed icon -->
                 </span>
                 <input type="range" id="speed-slider" min="0.5" max="2" step="0.1" value="1" title="Playback Speed Control">
                 <span id="speed-display">1.0x</span>
             </div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const selectFolderBtn = document.getElementById('select-folder-btn');
        const addFilesBtn = document.getElementById('add-files-btn');
        const folderInput = document.getElementById('folder-input');
        const addFilesInput = document.getElementById('add-files-input');

        const playlistElement = document.getElementById('playlist');
        const audioPlayer = document.getElementById('audio-player');
        const currentTrackNameElement = document.getElementById('current-track-name');
        const currentTimeElement = document.getElementById('current-time');
        const totalTimeElement = document.getElementById('total-time');
        const progressBar = document.getElementById('progress-bar');
        const prevBtn = document.getElementById('prev-btn');
        const playPauseBtn = document.getElementById('play-pause-btn');
        const nextBtn = document.getElementById('next-btn');
        const playIcon = document.getElementById('play-icon');
        const pauseIcon = document.getElementById('pause-icon');
        const volumeSlider = document.getElementById('volume-slider');
        const speedSlider = document.getElementById('speed-slider');
        const speedDisplay = document.getElementById('speed-display');
        const shuffleBtn = document.getElementById('shuffle-btn');
        const repeatBtn = document.getElementById('repeat-btn');
        const repeatBtnState = document.getElementById('repeat-btn-state');

        // --- State Variables ---
        let playlist = [];
        let currentTrackIndex = -1; // Index in ORIGINAL playlist
        let isPlaying = false;
        let currentObjectUrl = null;
        let isShuffle = false;
        let repeatMode = 0;
        let shuffledPlaylistIndices = [];
        let currentShuffleIndex = -1; // Index in shuffledPlaylistIndices

        // Removed Multi-click state variables

        const ALLOWED_EXTENSIONS = ['.mp3', '.wav', '.ogg', '.m4a', '.flac'];

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', initializePlayer);

        // --- Event Listeners ---
        selectFolderBtn.addEventListener('click', () => folderInput.click());
        addFilesBtn.addEventListener('click', () => addFilesInput.click());

        folderInput.addEventListener('change', handleFolderSelected);
        addFilesInput.addEventListener('change', handleAddFiles);

        // Playback Controls
        playPauseBtn.addEventListener('click', togglePlayPause); // Direct call now
        prevBtn.addEventListener('click', playPrevious);
        nextBtn.addEventListener('click', playNext);
        shuffleBtn.addEventListener('click', toggleShuffle);
        repeatBtn.addEventListener('click', cycleRepeatMode);

        // Audio Player Events
        audioPlayer.addEventListener('ended', handleTrackEnd);
        audioPlayer.addEventListener('timeupdate', updateProgress);
        audioPlayer.addEventListener('loadedmetadata', updateTrackMetadata);
        audioPlayer.addEventListener('play', () => updatePlayPauseButton(true));
        audioPlayer.addEventListener('pause', () => updatePlayPauseButton(false));
        audioPlayer.addEventListener('error', handleAudioError);

        // Sliders
        progressBar.addEventListener('input', seek);
        volumeSlider.addEventListener('input', setVolume);
        speedSlider.addEventListener('input', setSpeed);

        // Playlist Click (Combined Play and Remove)
        playlistElement.addEventListener('click', handlePlaylistInteraction);

        // Local Storage for Settings
        volumeSlider.addEventListener('change', () => localStorage.setItem('musicPlayerVolume', volumeSlider.value));
        speedSlider.addEventListener('change', () => localStorage.setItem('musicPlayerSpeed', speedSlider.value));
        shuffleBtn.addEventListener('click', () => localStorage.setItem('musicPlayerShuffle', isShuffle.toString()));
        repeatBtn.addEventListener('click', () => localStorage.setItem('musicPlayerRepeat', repeatMode.toString()));


        // --- Core Functions ---

        function initializePlayer() {
             playlist = []; currentTrackIndex = -1; isPlaying = false;
             isShuffle = false; repeatMode = 0; shuffledPlaylistIndices = []; currentShuffleIndex = -1;
             clearPlaylistDisplay(); resetPlayerUI(); loadSettings();
             updateControlsState(); updateShuffleButtonUI(); updateRepeatButtonUI();
        }

        function loadSettings() {
             const savedVolume = localStorage.getItem('musicPlayerVolume');
             volumeSlider.value = savedVolume !== null ? savedVolume : '1';
             setVolume();
             const savedSpeed = localStorage.getItem('musicPlayerSpeed');
             speedSlider.value = savedSpeed !== null ? savedSpeed : '1';
             setSpeed();
             const savedShuffle = localStorage.getItem('musicPlayerShuffle');
             isShuffle = savedShuffle === 'true';
             const savedRepeat = localStorage.getItem('musicPlayerRepeat');
             repeatMode = savedRepeat !== null ? parseInt(savedRepeat, 10) : 0;
             if (isNaN(repeatMode) || repeatMode < 0 || repeatMode > 2) repeatMode = 0;
             updateShuffleButtonUI();
             updateRepeatButtonUI();
        }

        // --- File Handling ---

        function filterAudioFiles(files) {
            const validFiles = [];
            if (!files) return validFiles;
            for (const file of files) {
                const extension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();
                if (ALLOWED_EXTENSIONS.includes(extension)) {
                     if (!validFiles.some(f => f.name === file.name && f.size === file.size)) {
                        validFiles.push(file);
                     }
                }
            }
            return validFiles;
        }

        function handleFolderSelected(event) {
            console.log("handleFolderSelected triggered");
            const files = event.target.files;
            const validFiles = filterAudioFiles(files);
            console.log("Valid files found:", validFiles.length);

            resetPlayerUI(true);
            playlist = [];
            shuffledPlaylistIndices = [];
            currentShuffleIndex = -1;
            currentTrackIndex = -1;

            if (validFiles.length > 0) {
                playlist = validFiles;
                playlist.sort((a, b) => a.name.localeCompare(b.name));
                if (isShuffle) {
                    generateShuffledList();
                }
                displayPlaylist();
                const firstTrackIndex = isShuffle ? (shuffledPlaylistIndices[0] ?? -1) : 0;
                if (firstTrackIndex !== -1) {
                    playTrackByIndex(firstTrackIndex);
                } else {
                    updateControlsState();
                }
            } else {
                if (files && files.length > 0) {
                    alert("No supported audio files found in the selected folder.");
                }
                clearPlaylistDisplay();
                updateControlsState();
            }
            event.target.value = null;
        }


        function handleAddFiles(event) {
            console.log("handleAddFiles triggered");
            const files = event.target.files;
            const newValidFiles = filterAudioFiles(files);
            console.log("New valid files to add:", newValidFiles.length);

            if (newValidFiles.length === 0) {
                 if (files && files.length > 0) {
                      alert("No supported audio files selected or found/all duplicates.");
                 }
                 event.target.value = null;
                 return;
            }

            const wasPlaylistEmpty = playlist.length === 0;
            const playerWasIdle = !isPlaying && currentTrackIndex === -1;
            const playingTrackName = currentTrackIndex !== -1 ? playlist[currentTrackIndex]?.name : null;

            let addedCount = 0;
            newValidFiles.forEach(newFile => {
                if (!playlist.some(existing => existing.name === newFile.name && existing.size === newFile.size)) {
                    playlist.push(newFile);
                    addedCount++;
                }
            });

            console.log("Files actually added (non-duplicates):", addedCount);

            if (addedCount > 0) {
                playlist.sort((a, b) => a.name.localeCompare(b.name));

                 let newPlayingOriginalIndex = -1;
                 if (playingTrackName) {
                    newPlayingOriginalIndex = playlist.findIndex(f => f.name === playingTrackName);
                    currentTrackIndex = newPlayingOriginalIndex;
                 } else {
                    currentTrackIndex = -1;
                 }

                if (isShuffle) {
                    generateShuffledList(); // Regenerate shuffle list
                    if(currentTrackIndex !== -1) {
                         currentShuffleIndex = shuffledPlaylistIndices.indexOf(currentTrackIndex);
                         if (currentShuffleIndex === -1) { console.warn("Playing track not found after adding+shuffle regen."); }
                    } else {
                         currentShuffleIndex = -1;
                    }
                }

                displayPlaylist(); // Re-render the list

                if (wasPlaylistEmpty && playerWasIdle) {
                    const firstTrackIndex = isShuffle ? (shuffledPlaylistIndices[0] ?? -1) : 0;
                     if (firstTrackIndex !== -1) {
                        playTrackByIndex(firstTrackIndex);
                     } else {
                         updateControlsState();
                     }
                } else {
                    updateControlsState(); // Just update controls if already playing/paused
                }
            } else {
                 alert("Selected file(s) are already in the playlist.");
            }

            event.target.value = null;
        }

        // --- Playlist & Shuffle Logic ---

        function shuffleArray(array) {
             for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; }
        }

        function generateShuffledList() {
             if (playlist.length === 0) { shuffledPlaylistIndices = []; currentShuffleIndex = -1; return; }
             shuffledPlaylistIndices = Array.from(playlist.keys());
             shuffleArray(shuffledPlaylistIndices);
             console.log("Generated Shuffle Indices:", shuffledPlaylistIndices);
             currentShuffleIndex = -1; // Reset current shuffle index
        }

        function toggleShuffle() {
             isShuffle = !isShuffle;
             localStorage.setItem('musicPlayerShuffle', isShuffle.toString());
             updateShuffleButtonUI();

             if (isShuffle) {
                 generateShuffledList();
                 if (currentTrackIndex !== -1) {
                    currentShuffleIndex = shuffledPlaylistIndices.indexOf(currentTrackIndex);
                    if (currentShuffleIndex === -1) { console.warn("Current track index not found in new shuffle list after toggle!"); }
                 } else {
                     currentShuffleIndex = -1;
                 }
             } else {
                 shuffledPlaylistIndices = [];
                 currentShuffleIndex = -1;
             }
        }

        function cycleRepeatMode() {
            repeatMode = (repeatMode + 1) % 3;
            localStorage.setItem('musicPlayerRepeat', repeatMode.toString());
            updateRepeatButtonUI();
        }

        function handlePlaylistInteraction(event) {
            const target = event.target;
            if (target.classList.contains('remove-btn')) {
                 event.stopPropagation();
                const indexToRemove = parseInt(target.dataset.removeIndex, 10);
                if (!isNaN(indexToRemove)) {
                    removeTrack(indexToRemove);
                }
            }
            else if (target.closest('li')) {
                 const listItem = target.closest('li');
                 const clickedOriginalIndex = parseInt(listItem.dataset.index, 10);
                 if (!isNaN(clickedOriginalIndex) && clickedOriginalIndex !== currentTrackIndex) {
                     playTrackByIndex(clickedOriginalIndex);
                 }
            }
        }

        // --- Track Removal ---
        function removeTrack(originalIndexToRemove) {
            if (originalIndexToRemove < 0 || originalIndexToRemove >= playlist.length) {
                console.warn("Invalid index to remove:", originalIndexToRemove);
                return;
            }

            const removedFile = playlist[originalIndexToRemove];
            console.log(`Removing track: "${removedFile.name}" at original index ${originalIndexToRemove}`);

            const wasPlaying = (originalIndexToRemove === currentTrackIndex);
            const playingIndexBeforeRemove = currentTrackIndex;
            const shuffleIndexBeforeRemove = currentShuffleIndex;

            // 1. Stop playback if removing the current track
            if (wasPlaying) {
                audioPlayer.pause();
                audioPlayer.removeAttribute('src');
                if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
                isPlaying = false;
                 currentTrackIndex = -1;
                 currentShuffleIndex = -1;
                 updatePlayPauseButton(false);
                 resetPlayerUI(true); // Keep list visible but reset player state
            }

            // 2. Remove from the main playlist array
             playlist.splice(originalIndexToRemove, 1);

            // 3. Determine the track that *was* playing's new index (if it wasn't the one removed)
            let newPlayingOriginalIndex = -1;
            if(playingIndexBeforeRemove !== -1 && !wasPlaying) {
                 newPlayingOriginalIndex = (originalIndexToRemove < playingIndexBeforeRemove) ? playingIndexBeforeRemove - 1 : playingIndexBeforeRemove;
                 currentTrackIndex = newPlayingOriginalIndex;
            }
            // If wasPlaying, currentTrackIndex remains -1

             // 4. Update shuffle list and indices
            let nextShuffleIndexToPlay = -1;
            if (isShuffle) {
                const removedShufflePos = shuffledPlaylistIndices.indexOf(originalIndexToRemove);
                if (removedShufflePos !== -1) { shuffledPlaylistIndices.splice(removedShufflePos, 1); }
                 shuffledPlaylistIndices = shuffledPlaylistIndices.map(idx => idx > originalIndexToRemove ? idx - 1 : idx);

                 if (currentTrackIndex !== -1) { // If a track was playing (and wasn't removed)
                     currentShuffleIndex = shuffledPlaylistIndices.indexOf(currentTrackIndex);
                     if (currentShuffleIndex === -1) {
                         console.error("Consistency Error: Playing track not found in shuffle after removal update!");
                         isShuffle = false; updateShuffleButtonUI(); // Turn off shuffle
                     }
                 } else { currentShuffleIndex = -1; }

                 if (wasPlaying && playlist.length > 0) {
                      if (removedShufflePos !== -1 && removedShufflePos < shuffledPlaylistIndices.length) {
                          nextShuffleIndexToPlay = removedShufflePos;
                      } else if (shuffledPlaylistIndices.length > 0 && repeatMode === 1) {
                          nextShuffleIndexToPlay = 0;
                      }
                 }
            } else { currentShuffleIndex = -1; }

            // 5. Update UI
             displayPlaylist();
             updateControlsState();

            // 6. Play the next track if the currently playing one was removed
             if (wasPlaying && playlist.length > 0) {
                 let nextOriginalIndexToPlay = -1;
                 if (isShuffle) {
                     if (nextShuffleIndexToPlay !== -1) { nextOriginalIndexToPlay = shuffledPlaylistIndices[nextShuffleIndexToPlay]; }
                 } else { // Not shuffling
                     if (originalIndexToRemove < playlist.length) { nextOriginalIndexToPlay = originalIndexToRemove; }
                     else if (repeatMode === 1) { nextOriginalIndexToPlay = 0; }
                 }

                 if (nextOriginalIndexToPlay !== -1) {
                     console.log("Playing next track after removal, index:", nextOriginalIndexToPlay);
                     playTrackByIndex(nextOriginalIndexToPlay);
                 } else { console.log("No next track to play after removal."); }
             } else if (wasPlaying && playlist.length === 0) { console.log("Playlist empty after removing playing track."); }
        }


        // --- Playback Logic ---

        function playTrackByIndex(originalIndex) {
             if (originalIndex < 0 || originalIndex >= playlist.length) { console.warn("PlayTrackByIndex: Invalid original index", originalIndex); resetPlayerUI(true); displayPlaylist(); return; }

             audioPlayer.pause();
             audioPlayer.removeAttribute('src');
             if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }

             currentTrackIndex = originalIndex;

             if (isShuffle) {
                 currentShuffleIndex = shuffledPlaylistIndices.indexOf(originalIndex);
                 if (currentShuffleIndex === -1) {
                     console.error(`Consistency Error: Index ${originalIndex} not in shuffle! Regenerating.`);
                     generateShuffledList();
                     currentShuffleIndex = shuffledPlaylistIndices.indexOf(originalIndex);
                     if (currentShuffleIndex === -1) { resetPlayerUI(true); displayPlaylist(); return; }
                 }
             } else { currentShuffleIndex = -1; }

             const file = playlist[currentTrackIndex];
             console.log(`Playing "${file.name}" (Original Index: ${currentTrackIndex}, Shuffle Index: ${currentShuffleIndex})`);
             currentTrackNameElement.textContent = file.name;

             currentTimeElement.textContent = formatTime(0);
             totalTimeElement.textContent = formatTime(NaN);
             progressBar.value = 0;
             progressBar.disabled = true;
             updatePlayPauseButton(false);

             try {
                 currentObjectUrl = URL.createObjectURL(file);
                 audioPlayer.src = currentObjectUrl;
                 audioPlayer.load();
                 setVolume();
                 setSpeed();
                 const playPromise = audioPlayer.play();

                 if (playPromise !== undefined) {
                     playPromise.then(() => { updateUIForNewTrack(); }).catch(error => { handleAudioError(error); });
                 } else { updateUIForNewTrack(); }
             } catch (error) { console.error("Error loading/playing track:", file.name, error); alert(`Error loading file: ${file.name}`); resetPlayerUI(true); displayPlaylist(); }
        }

        function handleTrackEnd() {
             console.log("Track ended. RepeatMode:", repeatMode, "isShuffle:", isShuffle);
             if (repeatMode === 2) { audioPlayer.currentTime = 0; audioPlayer.play().catch(handleAudioError); console.log("Repeating single track"); }
             else { playNext(true); }
        }

        function playNext(fromEnded = false) {
             if (playlist.length === 0) return;

             let nextOriginalIndex = -1;
             let nextShuffleIndex = -1;

             if (isShuffle) {
                 if (shuffledPlaylistIndices.length === 0) return;
                 if (currentShuffleIndex === -1) { nextShuffleIndex = 0; }
                 else if (currentShuffleIndex < shuffledPlaylistIndices.length - 1) { nextShuffleIndex = currentShuffleIndex + 1; }
                 else {
                     if (repeatMode === 1) { nextShuffleIndex = 0; }
                     else { if (fromEnded) resetPlayerUI(true); return; }
                 }
                 if (nextShuffleIndex !== -1) { nextOriginalIndex = shuffledPlaylistIndices[nextShuffleIndex]; }
             } else {
                 if (currentTrackIndex === -1 && playlist.length > 0) { nextOriginalIndex = 0; }
                 else if (currentTrackIndex < playlist.length - 1) { nextOriginalIndex = currentTrackIndex + 1; }
                 else {
                     if (repeatMode === 1) { nextOriginalIndex = 0; }
                     else { if (fromEnded) resetPlayerUI(true); return; }
                 }
             }

             if (nextOriginalIndex !== -1 && nextOriginalIndex < playlist.length) { playTrackByIndex(nextOriginalIndex); }
             else { console.warn(`Could not determine valid next track.`); if (fromEnded) resetPlayerUI(true); }
        }


        function playPrevious() {
             if (playlist.length === 0) return;
             if (audioPlayer.currentTime > 3 && currentTrackIndex !== -1) { audioPlayer.currentTime = 0; return; }

             let prevOriginalIndex = -1;
             let prevShuffleIndex = -1;

             if (isShuffle) {
                  if (shuffledPlaylistIndices.length === 0) return;
                 if (currentShuffleIndex <= 0) {
                     if (repeatMode === 1) { prevShuffleIndex = shuffledPlaylistIndices.length - 1; }
                     else { prevShuffleIndex = 0; }
                 } else { prevShuffleIndex = currentShuffleIndex - 1; }

                 if (prevShuffleIndex !== -1 && prevShuffleIndex < shuffledPlaylistIndices.length) { prevOriginalIndex = shuffledPlaylistIndices[prevShuffleIndex]; }
                 else if (shuffledPlaylistIndices.length > 0) { prevOriginalIndex = shuffledPlaylistIndices[0]; }

             } else {
                 if (currentTrackIndex <= 0) {
                     if (repeatMode === 1 && playlist.length > 0) { prevOriginalIndex = playlist.length - 1; }
                     else { prevOriginalIndex = 0; }
                 } else { prevOriginalIndex = currentTrackIndex - 1; }
             }

             if (prevOriginalIndex !== -1 && prevOriginalIndex < playlist.length) { playTrackByIndex(prevOriginalIndex); }
             else { if (playlist.length > 0) playTrackByIndex(isShuffle ? (shuffledPlaylistIndices[0] ?? 0) : 0); }
        }


        // --- Simplified Play/Pause Handler ---
        function togglePlayPause() {
            // If no track loaded but playlist exists, play first (respecting shuffle)
             if (currentTrackIndex === -1 && playlist.length > 0) {
                 const firstIdx = isShuffle ? (shuffledPlaylistIndices[0] ?? -1) : 0;
                 if (firstIdx !== -1) playTrackByIndex(firstIdx);
             } else if (currentTrackIndex !== -1 && audioPlayer.readyState >= 1) { // If track loaded, toggle
                 if (isPlaying) {
                    audioPlayer.pause();
                 } else {
                    audioPlayer.play().catch(handleAudioError);
                 }
             }
             // If no tracks, or readyState is 0, do nothing on click
        }


        // --- UI Update Functions ---
        function updateShuffleButtonUI() {
             shuffleBtn.classList.toggle('active', isShuffle);
             shuffleBtn.title = isShuffle ? "Shuffle On" : "Shuffle Off";
        }
        function updateRepeatButtonUI() {
             repeatBtn.classList.toggle('active', repeatMode !== 0);
             repeatBtnState.style.display = (repeatMode === 2) ? 'block' : 'none';
             if (repeatMode === 0) repeatBtn.title = "Repeat Off";
             else if (repeatMode === 1) repeatBtn.title = "Repeat Playlist";
             else repeatBtn.title = "Repeat Single";
        }
        function updatePlayPauseButton(playing) { // Updates icon and state
              isPlaying = playing;
              playIcon.style.display = playing ? 'none' : 'inline';
              pauseIcon.style.display = playing ? 'inline' : 'none';
              // Update title based on actual state
              playPauseBtn.title = playing ? "Pause" : "Play";
        }
        function updateControlsState() { // Enables/disables buttons
             const hasTracks = playlist.length > 0;
             playPauseBtn.disabled = !hasTracks;
             prevBtn.disabled = !hasTracks;
             nextBtn.disabled = !hasTracks;
             shuffleBtn.disabled = !hasTracks;
             repeatBtn.disabled = !hasTracks;
             const isMediaReady = currentTrackIndex >= 0 && hasTracks && !isNaN(audioPlayer.duration) && audioPlayer.duration > 0;
             progressBar.disabled = !isMediaReady;

             if (!hasTracks || currentTrackIndex < 0) {
                  if(!hasTracks) currentTrackNameElement.textContent = "Load music to start";
                  else currentTrackNameElement.textContent = "Select a track";
                  progressBar.value = 0;
                  currentTimeElement.textContent = formatTime(0);
                  totalTimeElement.textContent = formatTime(NaN);
                  progressBar.disabled = true;
                  progressBar.removeAttribute('max');
             }
        }
        function updateUIForNewTrack() { // Called after successful playback start
            if (currentTrackIndex < 0 || currentTrackIndex >= playlist.length) return;
            currentTrackNameElement.textContent = playlist[currentTrackIndex].name;
            const listItems = playlistElement.querySelectorAll('li');
            listItems.forEach((item, idx) => {
                item.classList.toggle('active', parseInt(item.dataset.index, 10) === currentTrackIndex);
            });
            const activeItem = playlistElement.querySelector('li.active');
             if (activeItem) { activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
            updateControlsState();
        }
        function displayPlaylist() { // Renders list items
            const playingTrackOriginalIndex = currentTrackIndex;
            playlistElement.innerHTML = '';
            if (playlist.length === 0) { clearPlaylistDisplay(); updateControlsState(); return; }

            playlist.forEach((file, originalIndex) => {
                const listItem = document.createElement('li');
                listItem.dataset.index = originalIndex;
                const trackNameSpan = document.createElement('span');
                trackNameSpan.className = 'track-name';
                trackNameSpan.textContent = file.name;
                trackNameSpan.title = file.name;
                listItem.appendChild(trackNameSpan);
                const removeButton = document.createElement('button');
                removeButton.className = 'remove-btn';
                removeButton.innerHTML = '&times;';
                removeButton.title = `Remove "${file.name}"`;
                removeButton.dataset.removeIndex = originalIndex;
                listItem.appendChild(removeButton);
                if (originalIndex === playingTrackOriginalIndex && playingTrackOriginalIndex !== -1) { listItem.classList.add('active'); }
                playlistElement.appendChild(listItem);
            });
            updateControlsState();
            const activeItem = playlistElement.querySelector('li.active');
            if (activeItem) { activeItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' }); }
        }


        function updateTrackMetadata() { /* ... (same as before) ... */
            const duration = audioPlayer.duration;
            if (typeof duration === 'number' && isFinite(duration) && duration > 0) {
                progressBar.max = duration; totalTimeElement.textContent = formatTime(duration); progressBar.disabled = false;
            } else { totalTimeElement.textContent = formatTime(NaN); progressBar.disabled = true; }
        }
        function updateProgress() { /* ... (same as before) ... */
             if (isPlaying && audioPlayer.readyState >= 2 && !isNaN(audioPlayer.duration) && audioPlayer.duration > 0) {
                if (!progressBar.matches(':active')) { progressBar.value = audioPlayer.currentTime; }
                currentTimeElement.textContent = formatTime(audioPlayer.currentTime);
            } else if (!isPlaying && audioPlayer.readyState >= 2 && currentTrackIndex !== -1) {
                 currentTimeElement.textContent = formatTime(audioPlayer.currentTime);
            }
        }
        function seek() { /* ... (same as before) ... */
            if (audioPlayer.readyState >= 2 && !isNaN(audioPlayer.duration) && audioPlayer.duration > 0) {
                audioPlayer.currentTime = progressBar.value; currentTimeElement.textContent = formatTime(audioPlayer.currentTime);
            } else { console.warn("Seek ignored: audio not ready or duration invalid."); }
        }
        function setVolume() { if (audioPlayer) { audioPlayer.volume = volumeSlider.value; } }
        function setSpeed() {
             if (audioPlayer) { const speed = parseFloat(speedSlider.value); audioPlayer.playbackRate = speed; speedDisplay.textContent = `${speed.toFixed(1)}x`; }
        }
        function handleAudioError(e) { /* ... (same as before) ... */
            console.error("Audio Error:", e); let message = "An unknown audio error occurred."; if (audioPlayer.error) { /* error code mapping */ }
             const trackName = currentTrackIndex !== -1 ? playlist[currentTrackIndex]?.name : "the current track"; alert(`Error playing ${trackName}: ${message}`);
             resetPlayerUI(true); currentTrackIndex = -1; currentShuffleIndex = -1; displayPlaylist(); updateControlsState();
        }
        function resetPlayerUI(keepPlaylistDisplay = false) {
            console.log("Resetting Player UI", keepPlaylistDisplay ? "(keeping list display)" : "");
            audioPlayer.pause(); audioPlayer.removeAttribute('src');
             if (currentObjectUrl) { URL.revokeObjectURL(currentObjectUrl); currentObjectUrl = null; }
             if (!keepPlaylistDisplay) { currentTrackIndex = -1; currentShuffleIndex = -1; }
            isPlaying = false; updatePlayPauseButton(false);
            currentTrackNameElement.textContent = "No track loaded"; currentTimeElement.textContent = formatTime(0);
            totalTimeElement.textContent = formatTime(NaN); progressBar.value = 0; progressBar.disabled = true; progressBar.removeAttribute('max');
            if (!keepPlaylistDisplay) { playlistElement.innerHTML = '<li>Playlist is empty</li>'; }
            else { const activeItem = playlistElement.querySelector('li.active'); if (activeItem) activeItem.classList.remove('active'); }
        }
        function clearPlaylistDisplay() {
            playlistElement.innerHTML = '<li>Playlist is empty</li>'; currentTrackNameElement.textContent = "No track loaded";
            currentTimeElement.textContent = formatTime(0); totalTimeElement.textContent = formatTime(NaN);
        }
        function formatTime(seconds) {
             if (typeof seconds !== 'number' || !isFinite(seconds) || seconds < 0) { return "--:--"; }
            const minutes = Math.floor(seconds / 60); const secs = Math.floor(seconds % 60);
            return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
        }

    </script>

</body>
</html>
